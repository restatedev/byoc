import { Construct } from "constructs";
import * as cdk from "aws-cdk-lib";
import * as cloudwatch from "aws-cdk-lib/aws-cloudwatch";
import {
  DEFAULT_OTEL_COLLECTOR_CPU,
  DEFAULT_OTEL_COLLECTOR_IMAGE,
  DEFAULT_OTEL_COLLECTOR_MEMORY_LIMIT_MIB,
  DEFAULT_RESTATE_CPU,
  DEFAULT_RESTATE_MEMORY_LIMIT_MIB,
  MonitoringProps,
  OtelCollectorProps,
  ClusterProps,
  SupportedRestateVersion,
} from "./props";
import type { ControlPanelWidgetEvent } from "./lambda/cloudwatch-custom-widget/index.mjs";

export function createMonitoring(
  scope: Construct,
  stackVersion: string,
  clusterName: string,
  vpc: cdk.aws_ec2.IVpc,
  subnets: cdk.aws_ec2.SelectedSubnets,
  securityGroups: cdk.aws_ec2.ISecurityGroup[],
  bucket: cdk.aws_s3.IBucket,
  ecsCluster: cdk.aws_ecs.ICluster,
  statelessService: cdk.aws_ecs.IFargateService,
  statelessTaskDefinition: cdk.aws_ecs.FargateTaskDefinition,
  statelessRestateVersion: SupportedRestateVersion,
  statefulTaskDefinition: cdk.aws_ecs.FargateTaskDefinition,
  controllerService: cdk.aws_ecs.IFargateService,
  controllerTaskDefinition: cdk.aws_ecs.FargateTaskDefinition,
  loadBalancer: {
    ingress: {
      loadBalancerArn: string;
      certificateArn?: string;
      address: string;
    };
    admin: {
      loadBalancerArn: string;
      address: string;
    };
    webUI: {
      address: string;
    };
  },
  customWidgetCode: cdk.aws_lambda.Code,
  lambdaRetention: cdk.aws_logs.RetentionDays,
  restatectlLambda?: cdk.aws_lambda.IFunction,
  props?: ClusterProps,
): {
  metricsDashboard?: cloudwatch.Dashboard;
  controlPanelDashboard?: cloudwatch.Dashboard;
  customWidgetFn?: cdk.aws_lambda.IFunction;
  customWidgetLogGroup?: cdk.aws_logs.ILogGroup;
} {
  const customWidget = createCustomWidgetLambda(
    scope,
    vpc,
    subnets,
    ecsCluster,
    [controllerService, statelessService],
    customWidgetCode,
    lambdaRetention,
    restatectlLambda,
    props?.monitoring,
    props,
  );

  const customWidgetFn = customWidget?.fn;
  const customWidgetLogGroup = customWidget?.logGroup;

  const metricsDashboard = createMetricsDashboard(
    scope,
    ecsCluster,
    statelessTaskDefinition,
    statefulTaskDefinition,
    controllerTaskDefinition,
    customWidgetFn,
    props,
  );

  let controlPanelDashboard: cloudwatch.Dashboard | undefined;
  if (customWidgetFn && restatectlLambda) {
    if (!props?.monitoring?.dashboard?.controlPanel?.disabled) {
      controlPanelDashboard = new cloudwatch.Dashboard(scope, "control-panel", {
        dashboardName: props?.monitoring?.dashboard?.controlPanel
          ?.autogeneratedName
          ? undefined
          : `${scope.node.path.replaceAll("/", "_")}_control-panel`,
      });
      cdk.Tags.of(controlPanelDashboard).add(
        "Name",
        controlPanelDashboard.node.path,
      );

      controlPanelDashboard.addWidgets(
        new cloudwatch.CustomWidget({
          title: "",
          functionArn: customWidgetFn.functionArn,
          width: 24,
          height: 26,
          params: {
            command: "controlPanel",
            input: {
              region: cdk.Aws.REGION,
              summary: {
                clusterName,
                restateVersion: statelessRestateVersion,
                stackVersion: stackVersion,
                metricsDashboardName: metricsDashboard?.dashboardName,
              },
              resources: {
                ecsClusterArn: ecsCluster.clusterArn,
                statelessServiceArn: statelessService.serviceArn,
                controllerServiceArn: controllerService.serviceArn,
                restatectlLambdaArn: restatectlLambda?.functionArn,
              },
              connectivityAndSecurity: {
                connectivity: {
                  loadBalancerArns: {
                    ingress: [loadBalancer.ingress.loadBalancerArn],
                    admin: [loadBalancer.admin.loadBalancerArn],
                  },
                  addresses: {
                    ingress: loadBalancer.ingress.address,
                    admin: loadBalancer.admin.address,
                    webUI: loadBalancer.webUI.address,
                  },
                },
                networking: {
                  vpc: vpc.vpcId,
                  availabilityZones: subnets.availabilityZones,
                  subnets: subnets.subnetIds,
                },
                security: {
                  securityGroups: securityGroups.map(
                    (sg) => sg.securityGroupId,
                  ),
                  certificateArn: loadBalancer.ingress.certificateArn,
                },
              },
              storage: {
                s3: {
                  bucket: bucket.bucketName,
                },
              },
            },
          } satisfies ControlPanelWidgetEvent,
        }),
      );
    }
  }

  return {
    metricsDashboard,
    controlPanelDashboard,
    customWidgetFn,
    customWidgetLogGroup,
  };
}

export function createMetricsDashboard(
  scope: Construct,
  cluster: cdk.aws_ecs.ICluster,
  statelessTaskDefinition: cdk.aws_ecs.FargateTaskDefinition,
  statefulTaskDefinition: cdk.aws_ecs.FargateTaskDefinition,
  controllerTaskDefinition: cdk.aws_ecs.FargateTaskDefinition,
  customWidgetFn?: cdk.aws_lambda.IFunction,
  props?: ClusterProps,
): cloudwatch.Dashboard | undefined {
  if (props?.monitoring?.dashboard?.metrics?.disabled) return;

  const metricsDashboard = new cloudwatch.Dashboard(scope, "metrics", {
    dashboardName: props?.monitoring?.dashboard?.metrics?.autogeneratedName
      ? undefined
      : `${scope.node.path.replaceAll("/", "_")}_metrics`,
  });
  cdk.Tags.of(metricsDashboard).add("Name", metricsDashboard.node.path);

  const cpuWidget = (title: string, taskFamily: string, cpuLimit: number) =>
    new cloudwatch.GraphWidget({
      title,
      view: cloudwatch.GraphWidgetView.TIME_SERIES,
      left: [
        new cloudwatch.MathExpression({
          expression: `SELECT AVG(CpuUtilized) FROM SCHEMA("ECS/ContainerInsights", ClusterName,TaskDefinitionFamily,TaskId) WHERE TaskDefinitionFamily = '${taskFamily}' GROUP BY TaskId`,
          label: "CPU",
        }),
      ],
      width: 12,
      height: 6,
      leftYAxis: {
        label: "vCPUs",
        showUnits: false,
      },
      leftAnnotations: [
        {
          value: cpuLimit,
          label: "Limit",
        },
      ],
    });

  const memoryWidget = (
    title: string,
    taskFamily: string,
    memoryLimit: number,
  ) =>
    new cloudwatch.GraphWidget({
      title,
      view: cloudwatch.GraphWidgetView.TIME_SERIES,
      left: [
        new cloudwatch.MathExpression({
          expression: `SELECT AVG(MemoryUtilized) FROM SCHEMA("ECS/ContainerInsights", ClusterName,TaskDefinitionFamily,TaskId) WHERE TaskDefinitionFamily = '${taskFamily}' GROUP BY TaskId`,
          label: "Memory",
        }),
      ],
      width: 12,
      height: 6,
      leftYAxis: {
        label: "MiB",
        showUnits: false,
      },
      leftAnnotations: [
        {
          value: memoryLimit,
          label: "Limit",
        },
      ],
    });

  const networkWidget = (title: string, taskFamily: string, typ: "Tx" | "Rx") =>
    new cloudwatch.GraphWidget({
      title: title,
      view: cloudwatch.GraphWidgetView.TIME_SERIES,
      left: [
        new cloudwatch.MathExpression({
          expression: `SELECT AVG(Network${typ}Bytes) FROM SCHEMA("ECS/ContainerInsights", ClusterName,TaskDefinitionFamily,TaskId) WHERE TaskDefinitionFamily = '${taskFamily}' GROUP BY TaskId`,
          label: typ,
        }),
      ],
      width: 12,
      height: 6,
      leftYAxis: {
        label: "Bytes/sec",
        showUnits: false,
      },
    });

  const ebsVolume = props?.statefulNode?.ebsVolume;

  let volumeSize: number;
  let iopsLimit: number;
  let throughputLimit: number;
  switch (ebsVolume?.volumeType) {
    case undefined:
    case cdk.aws_ec2.EbsDeviceVolumeType.GP2:
      if (!ebsVolume) {
        // default ephemeral volume, which is gp2
        volumeSize = 200;
        iopsLimit = 600;
        throughputLimit = 150;
        break;
      } else {
        // ebs volume, but requesting gp2
        if (cdk.isResolvableObject(ebsVolume.sizeInGiB))
          throw new Error("Cannot use a cfn token for gp2 volume size");
        volumeSize = ebsVolume.sizeInGiB;
        iopsLimit = Math.min(ebsVolume.sizeInGiB * 3, 16000);
        throughputLimit = Math.max(Math.min(iopsLimit / 4, 250), 128);
        break;
      }
    case cdk.aws_ec2.EbsDeviceVolumeType.IO1:
      if (!ebsVolume.iops)
        throw new Error("io1 volumes must have an iops configured");
      if (cdk.isResolvableObject(ebsVolume.iops))
        throw new Error("Cannot use a cfn token for io1 iops");
      volumeSize = ebsVolume.sizeInGiB;
      iopsLimit = ebsVolume.iops;
      throughputLimit = Math.max(
        /* limit256 = */ Math.min(iopsLimit / 2000, 500),
        /* limit16 = */ Math.min(iopsLimit / 64000, 1000),
      );
      break;
    case cdk.aws_ec2.EbsDeviceVolumeType.IO2:
      if (!ebsVolume.iops)
        throw new Error("io2 volumes must have an iops configured");
      if (cdk.isResolvableObject(ebsVolume.iops))
        throw new Error("Cannot use a cfn token for io2 iops");
      volumeSize = ebsVolume.sizeInGiB;
      iopsLimit = ebsVolume.iops;
      throughputLimit = Math.min(iopsLimit / 4, 4000);
      break;
    case cdk.aws_ec2.EbsDeviceVolumeType.GP3:
      volumeSize = ebsVolume.sizeInGiB;
      iopsLimit = ebsVolume.iops ?? 3000;
      throughputLimit = ebsVolume?.throughput ?? 125;
      break;
    case cdk.aws_ec2.EbsDeviceVolumeType.ST1:
      if (cdk.isResolvableObject(ebsVolume.sizeInGiB))
        throw new Error("Cannot use a cfn token for st1 volume size");
      volumeSize = ebsVolume.sizeInGiB;
      throughputLimit = Math.min((ebsVolume.sizeInGiB * 40) / 1000, 500);
      iopsLimit = throughputLimit; // assumes 1M i/o
      break;
    case cdk.aws_ec2.EbsDeviceVolumeType.SC1:
      if (cdk.isResolvableObject(ebsVolume.sizeInGiB))
        throw new Error("Cannot use a cfn token for sc1 volume size");
      volumeSize = ebsVolume.sizeInGiB;
      throughputLimit = Math.min((ebsVolume.sizeInGiB * 12) / 1000, 192);
      iopsLimit = throughputLimit; // assumes 1M i/o
      break;
    default:
      throw new Error(`Unexpected EBS volume type: ${ebsVolume?.volumeType}`);
  }

  const storageThroughputWidget = (title: string, typ: "Write" | "Read") =>
    new cloudwatch.GraphWidget({
      title: title,
      view: cloudwatch.GraphWidgetView.TIME_SERIES,
      left: [
        new cloudwatch.MathExpression({
          expression: `RATE(count) / 1048576`,
          label: typ,
          usingMetrics: {
            count: new cloudwatch.MathExpression({
              expression: `SELECT MAX(Storage${typ}Bytes) FROM SCHEMA("ECS/ContainerInsights", ClusterName,TaskDefinitionFamily,TaskId) WHERE TaskDefinitionFamily = '${statefulTaskDefinition.family}' GROUP BY TaskId`,
            }),
          },
        }),
      ],
      width: 8,
      height: 6,
      leftYAxis: {
        label: "MiB/sec",
        showUnits: false,
      },
      leftAnnotations: [
        {
          value: throughputLimit,
          label: "Limit",
          visible: false, // disable by default because it skews the graph so much
        },
      ],
    });

  const volumeUsageWidget = ebsVolume
    ? new cloudwatch.GraphWidget({
        title: `EBS Volume Usage (Total size ${volumeSize}GiB)`,
        view: cloudwatch.GraphWidgetView.TIME_SERIES,
        left: [
          new cloudwatch.MathExpression({
            expression: `SELECT MAX(EBSFilesystemUtilized) FROM SCHEMA("ECS/ContainerInsights", ClusterName,TaskDefinitionFamily,VolumeName) WHERE TaskDefinitionFamily = '${statefulTaskDefinition.family}' GROUP BY VolumeName`,
            label: "Usage",
          }),
        ],
        width: 8,
        height: 6,
        leftYAxis: {
          label: "GiB",
          showUnits: false,
        },
        leftAnnotations: [
          {
            value: volumeSize,
            label: "Volume size",
            visible: false, // disable by default because it skews the graph so much
          },
        ],
      })
    : new cloudwatch.GraphWidget({
        title: `Ephemeral Volume Usage (Total size ${volumeSize}GiB)`,
        left: [
          new cloudwatch.MathExpression({
            expression: `SELECT MAX(EphemeralStorageUtilized) FROM SCHEMA("ECS/ContainerInsights", ClusterName,TaskDefinitionFamily) WHERE TaskDefinitionFamily = '${statefulTaskDefinition.family}'`,
            label: "Usage",
          }),
        ],
        width: 8,
        height: 6,
        leftYAxis: {
          label: "GiB",
          showUnits: false,
        },
        leftAnnotations: [
          {
            value: volumeSize,
            label: "Volume size",
            visible: false, // disable by default because it skews the graph so much
          },
        ],
        liveData: false,
      });

  const logsWidget = (
    title: string,
    taskDefinition: cdk.aws_ecs.FargateTaskDefinition,
  ) => {
    if (
      taskDefinition.defaultContainer?.logDriverConfig?.logDriver ==
        "awslogs" &&
      taskDefinition.defaultContainer.logDriverConfig.options?.["awslogs-group"]
    ) {
      const logsGroup =
        taskDefinition.defaultContainer.logDriverConfig.options[
          "awslogs-group"
        ];
      const logsRegion: string | undefined =
        taskDefinition.defaultContainer.logDriverConfig.options[
          "awslogs-region"
        ];
      return [
        new cloudwatch.LogQueryWidget({
          title,
          width: 24,
          height: 6,
          logGroupNames: [logsGroup],
          region: logsRegion,
          queryString: `fields @logStream, @timestamp, level, fields.message, target
          | sort @timestamp desc
          | limit 500`,
        }),
      ];
    } else {
      return [];
    }
  };

  let iopsWidgets: cloudwatch.IWidget[] = [];
  if (customWidgetFn) {
    if (props?.statefulNode?.ebsVolume) {
      const iopsWidget = (typ: "Read" | "Write") =>
        new cloudwatch.GraphWidget({
          title: `EBS Volume ${typ} IOPS (Limited to ${iopsLimit})`,
          left: [
            new cloudwatch.MathExpression({
              label: "",
              // by including a pointless "SELECT" arg here we can avoid triggering CloudWatch:Math:UnknownIdentifier
              expression: `LAMBDA("${customWidgetFn.functionName}", "volumeIOPs", "${cluster.clusterName}", "${typ}", "SELECT")`,
            }),
          ],
          width: 12,
          height: 6,
          leftYAxis: {
            label: "IOPS",
            showUnits: false,
          },
          leftAnnotations: [
            {
              label: "Limit",
              value: iopsLimit,
              visible: false, // disable by default because it skews the graph so much
            },
          ],
        });

      iopsWidgets = [iopsWidget("Write"), iopsWidget("Read")];
    }
  }

  metricsDashboard.addWidgets(
    ...[
      cpuWidget(
        "Stateless CPU",
        statelessTaskDefinition.family,
        props?.statelessNode?.resources?.cpu ?? DEFAULT_RESTATE_CPU,
      ),
      memoryWidget(
        "Stateless Memory",
        statelessTaskDefinition.family,
        props?.statelessNode?.resources?.memoryLimitMiB ??
          DEFAULT_RESTATE_MEMORY_LIMIT_MIB,
      ),

      networkWidget(
        "Stateless Network Tx",
        statelessTaskDefinition.family,
        "Tx",
      ),
      networkWidget(
        "Stateless Network Rx",
        statelessTaskDefinition.family,
        "Rx",
      ),
    ],
    ...logsWidget("Stateless Logs", statelessTaskDefinition),
    ...[
      cpuWidget(
        "Stateful CPU",
        statefulTaskDefinition.family,
        props?.statefulNode?.resources?.cpu ?? DEFAULT_RESTATE_CPU,
      ),
      memoryWidget(
        "Stateful Memory",
        statefulTaskDefinition.family,
        props?.statefulNode?.resources?.memoryLimitMiB ??
          DEFAULT_RESTATE_MEMORY_LIMIT_MIB,
      ),

      networkWidget("Stateful Network Tx", statefulTaskDefinition.family, "Tx"),
      networkWidget("Stateful Network Rx", statefulTaskDefinition.family, "Rx"),
    ],
    ...logsWidget("Stateful Logs", statefulTaskDefinition),
    ...[
      volumeUsageWidget,
      storageThroughputWidget(
        `Volume Write Throughput (Limited to ${throughputLimit} MiB/sec)`,
        "Write",
      ),
      storageThroughputWidget(
        `Volume Read Throughput (Limited to ${throughputLimit} MiB/sec)`,
        "Read",
      ),
    ],
    ...iopsWidgets,
    ...logsWidget("Controller Logs", controllerTaskDefinition),
  );

  return metricsDashboard;
}

function createCustomWidgetLambda(
  scope: Construct,
  vpc: cdk.aws_ec2.IVpc,
  subnets: cdk.aws_ec2.SelectedSubnets,
  ecsCluster: cdk.aws_ecs.ICluster,
  ecsServices: cdk.aws_ecs.IService[],
  code: cdk.aws_lambda.Code,
  retention: cdk.aws_logs.RetentionDays,
  restatectlLambda?: cdk.aws_lambda.IFunction,
  monitoringProps?: MonitoringProps,
  clusterProps?: ClusterProps,
):
  | {
      fn: cdk.aws_lambda.Function;
      logGroup: cdk.aws_logs.ILogGroup;
    }
  | undefined {
  if (!restatectlLambda || monitoringProps?.dashboard?.customWidgets?.disabled)
    return;

  const logGroup = new cdk.aws_logs.LogGroup(
    scope,
    "cloudwatch-custom-widget-log-group",
    {
      retention: retention ?? cdk.aws_logs.RetentionDays.TWO_WEEKS,
    },
  );

  const role =
    monitoringProps?.dashboard?.customWidgets?.executionRole ??
    new cdk.aws_iam.Role(scope, "cloudwatch-custom-widget-execution-role", {
      assumedBy: new cdk.aws_iam.ServicePrincipal("lambda.amazonaws.com"),
    });

  role.addToPrincipalPolicy(
    new cdk.aws_iam.PolicyStatement({
      actions: ["logs:CreateLogStream", "logs:PutLogEvents"],
      resources: [
        `arn:${cdk.Aws.PARTITION}:logs:${cdk.Aws.REGION}:${cdk.Aws.ACCOUNT_ID}:log-group:${logGroup.logGroupName}:log-stream:*`,
      ],
      effect: cdk.aws_iam.Effect.ALLOW,
      sid: "AWSLambdaLogStreamPermissions",
    }),
  );

  if (monitoringProps?.dashboard?.customWidgets?.securityGroups?.length) {
    role.addToPrincipalPolicy(
      new cdk.aws_iam.PolicyStatement({
        actions: [
          "ec2:CreateNetworkInterface",
          "ec2:DescribeNetworkInterfaces",
          "ec2:DescribeSubnets",
          "ec2:DeleteNetworkInterface",
        ],
        resources: ["*"],
        effect: cdk.aws_iam.Effect.ALLOW,
        sid: "AWSLambdaVPCWildcardPermissions",
      }),
    );

    role.addToPrincipalPolicy(
      new cdk.aws_iam.PolicyStatement({
        actions: [
          "ec2:AssignPrivateIpAddresses",
          "ec2:UnassignPrivateIpAddresses",
        ],
        resources: [
          `arn:${cdk.Aws.PARTITION}:ec2:${cdk.Aws.REGION}:${cdk.Aws.ACCOUNT_ID}:network-interface/*`,
        ],
        effect: cdk.aws_iam.Effect.ALLOW,
        sid: "AWSLambdaVPCNetworkInterfacePermissions",
      }),
    );
  }

  role.addToPrincipalPolicy(
    new cdk.aws_iam.PolicyStatement({
      actions: ["lambda:InvokeFunction"],
      resources: [restatectlLambda.functionArn],
      effect: cdk.aws_iam.Effect.ALLOW,
      sid: "InvokeRestatectl",
    }),
  );

  if (clusterProps?.statefulNode?.ebsVolume) {
    role.addToPrincipalPolicy(
      new cdk.aws_iam.PolicyStatement({
        actions: [
          "ec2:DescribeVolumes",
          "ec2:DescribeVolumeStatus",
          "ec2:DescribeSnapshots",
        ],
        resources: ["*"],
        effect: cdk.aws_iam.Effect.ALLOW,
        sid: "EC2ReadActions",
      }),
    );
  }

  role.addToPrincipalPolicy(
    new cdk.aws_iam.PolicyStatement({
      actions: ["ecs:DescribeTaskDefinition"],
      resources: ["*"],
      effect: cdk.aws_iam.Effect.ALLOW,
      sid: "ECSReadActions",
    }),
  );

  role.addToPrincipalPolicy(
    new cdk.aws_iam.PolicyStatement({
      actions: ["ecs:ListTasks"],
      resources: ["*"],
      effect: cdk.aws_iam.Effect.ALLOW,
      conditions: {
        StringEquals: {
          "ecs:cluster": ecsCluster.clusterArn,
        },
      },
      sid: "ECSListTasks",
    }),
  );

  role.addToPrincipalPolicy(
    new cdk.aws_iam.PolicyStatement({
      actions: ["ecs:DescribeTasks"],
      resources: [
        `arn:${cdk.Aws.PARTITION}:ecs:${cdk.Aws.REGION}:${cdk.Aws.ACCOUNT_ID}:task/${ecsCluster.clusterName}/*`,
      ],
      effect: cdk.aws_iam.Effect.ALLOW,
      conditions: {
        StringEquals: {
          "ecs:cluster": ecsCluster.clusterArn,
        },
      },
      sid: "ECSDescribeTasks",
    }),
  );

  role.addToPrincipalPolicy(
    new cdk.aws_iam.PolicyStatement({
      actions: ["ecs:DescribeServices"],
      resources: ecsServices.map((service) => service.serviceArn),
      effect: cdk.aws_iam.Effect.ALLOW,
      conditions: {
        StringEquals: {
          "ecs:cluster": ecsCluster.clusterArn,
        },
      },
      sid: "ECSDescribeServices",
    }),
  );

  role.addToPrincipalPolicy(
    new cdk.aws_iam.PolicyStatement({
      actions: ["cloudwatch:GetMetricData"],
      resources: ["*"],
      effect: cdk.aws_iam.Effect.ALLOW,
      sid: "CloudWatchReadActions",
    }),
  );

  const fn = new cdk.aws_lambda.Function(
    scope,
    "cloudwatch-custom-widget-lambda",
    {
      role,
      runtime: cdk.aws_lambda.Runtime.NODEJS_22_X,
      architecture: cdk.aws_lambda.Architecture.ARM_64,
      memorySize: 1024,
      handler: "index.handler",
      code,
      logGroup,
      timeout: cdk.Duration.seconds(60),
      vpc: monitoringProps?.dashboard?.customWidgets?.securityGroups?.length
        ? vpc
        : undefined,
      vpcSubnets: monitoringProps?.dashboard?.customWidgets?.securityGroups
        ?.length
        ? subnets
        : undefined,
      securityGroups: monitoringProps?.dashboard?.customWidgets?.securityGroups,
      environment: {
        ENABLE_EBS_VOLUMES: clusterProps?.statefulNode?.ebsVolume
          ? "true"
          : "false",
      },
    },
  );
  cdk.Tags.of(fn).add("Name", fn.node.path);

  fn.addPermission("cloudwatch-custom-widget-lambda-allow-datasource", {
    principal: cdk.aws_iam.ServicePrincipal.fromStaticServicePrincipleName(
      "lambda.datasource.cloudwatch.amazonaws.com",
    ),
  });

  return { fn, logGroup };
}

export function otelCollectorContainerProps(
  clusterName: string,
  logDriver?: cdk.aws_ecs.LogDriver,
  otelCollectorProps?: OtelCollectorProps,
): cdk.aws_ecs.ContainerDefinitionOptions | undefined {
  if (!otelCollectorProps?.enabled) {
    return;
  }

  const otelConfig = otelCollectorConfig(otelCollectorProps);

  const otelCollectorCpu =
    otelCollectorProps.resources?.cpu ?? DEFAULT_OTEL_COLLECTOR_CPU;
  const otelCollectorMemoryLimitMiB =
    otelCollectorProps.resources?.memoryLimitMiB ??
    DEFAULT_OTEL_COLLECTOR_MEMORY_LIMIT_MIB;

  return {
    cpu: otelCollectorCpu,
    memoryLimitMiB: otelCollectorMemoryLimitMiB,
    image: cdk.aws_ecs.ContainerImage.fromRegistry(
      otelCollectorProps?.image ?? DEFAULT_OTEL_COLLECTOR_IMAGE,
    ),
    logging: logDriver,
    stopTimeout: cdk.Duration.seconds(30),
    healthCheck:
      otelCollectorProps.healthCheck === null
        ? undefined
        : (otelCollectorProps.healthCheck ?? {
            command: ["CMD", "/healthcheck"],
            timeout: cdk.Duration.seconds(5),
            interval: cdk.Duration.seconds(5),
          }),
    // we must not exit a restate node because otel failed
    essential: false,
    enableRestartPolicy: true,
    restartAttemptPeriod: cdk.Duration.seconds(60),
    secrets: otelCollectorProps.secrets,
    environment: {
      AOT_CONFIG_CONTENT: otelConfig,
      RESTATE_CLUSTER_NAME: clusterName,
    },
  };
}

function otelCollectorConfig(otelCollectorProps: OtelCollectorProps): string {
  if ("customConfig" in otelCollectorProps.configuration) {
    return otelCollectorProps.configuration.customConfig;
  }

  if (
    !otelCollectorProps.configuration.traceExporterIds?.length &&
    !otelCollectorProps.configuration.metricExporterIds?.length
  ) {
    throw new Error(
      "Otel collection configuration must include some traceExporterIds or metricExporterIds",
    );
  }

  for (const id of otelCollectorProps.configuration.traceExporterIds ?? []) {
    if (!(id in otelCollectorProps.configuration.exporters)) {
      throw new Error(
        `Otel collector is configured with a trace exporter ID ${id} which is not present in the 'exporters' object`,
      );
    }
  }

  for (const id of otelCollectorProps.configuration.metricExporterIds ?? []) {
    if (!(id in otelCollectorProps.configuration.exporters)) {
      throw new Error(
        `Otel collector is configured with a metric exporter ID ${id} which is not present in the 'exporters' object`,
      );
    }
  }

  const tracesPipeline = otelCollectorProps.configuration.traceExporterIds
    ?.length
    ? {
        traces: {
          receivers: ["otlp"],
          processors: ["batch/traces"],
          exporters: otelCollectorProps.configuration.traceExporterIds,
        },
      }
    : {};

  const metricsPipelines = otelCollectorProps.configuration.metricExporterIds
    ?.length
    ? {
        "metrics/restate": {
          receivers: ["prometheus"],
          processors: ["batch/metrics"],
          exporters: otelCollectorProps.configuration.metricExporterIds,
        },
        "metrics/ecs": {
          receivers: ["awsecscontainermetrics"],
          processors: ["filter/ecs", "metricstransform/ecs", "resource/ecs"],
          exporters: otelCollectorProps.configuration.metricExporterIds,
        },
      }
    : {};

  const config = {
    receivers: {
      otlp: {
        protocols: {
          grpc: {
            endpoint: "localhost:4317",
          },
        },
      },
      prometheus: {
        config: {
          scrape_configs: [
            {
              job_name: "restate",
              static_configs: [{ targets: ["localhost:5122"] }],
              scrape_interval: otelCollectorProps.configuration
                .restateScrapeInterval
                ? `${otelCollectorProps.configuration.restateScrapeInterval.toSeconds()}s`
                : "60s",
            },
          ],
        },
      },
      awsecscontainermetrics: {
        collection_interval: otelCollectorProps.configuration
          .ecsCollectionInterval
          ? `${otelCollectorProps.configuration.ecsCollectionInterval.toSeconds()}s`
          : "60s",
      },
    },

    processors: {
      "batch/traces": {
        timeout: "5s",
        send_batch_size: 50,
      },
      "batch/metrics": {
        timeout: "60s",
      },
      "filter/ecs": {
        metrics: {
          include: {
            match_type: "strict",
            metric_names: [
              "ecs.task.memory.reserved",
              "ecs.task.memory.utilized",
              "ecs.task.cpu.utilized",
              "ecs.task.cpu.reserved",
              "ecs.task.network.io.usage.rx_bytes",
              "ecs.task.network.io.usage.tx_bytes",
              "ecs.task.storage.read_bytes",
              "ecs.task.storage.write_bytes",
            ],
          },
        },
      },
      "metricstransform/ecs": {
        transforms: [
          {
            include: "ecs.task.memory.utilized",
            action: "update",
            new_name: "restate_ecs_memory_utilized",
          },
          {
            include: "ecs.task.memory.reserved",
            action: "update",
            new_name: "restate_ecs_memory_reserved",
          },
          {
            include: "ecs.task.cpu.utilized",
            action: "update",
            new_name: "restate_ecs_cpu_utilized",
          },
          {
            include: "ecs.task.cpu.reserved",
            action: "update",
            new_name: "restate_ecs_cpu_reserved",
          },
          {
            include: "ecs.task.network.io.usage.rx_bytes",
            action: "update",
            new_name: "restate_ecs_network_io_usage_rx_bytes",
          },
          {
            include: "ecs.task.network.io.usage.tx_bytes",
            action: "update",
            new_name: "restate_ecs_network_io_usage_tx_bytes",
          },
          {
            include: "ecs.task.storage.read_bytes",
            action: "update",
            new_name: "restate_ecs_storage_read_bytes",
          },
          {
            include: "ecs.task.storage.write_bytes",
            action: "update",
            new_name: "restate_ecs_storage_write_bytes",
          },
        ],
      },
      "resource/ecs": {
        attributes: [
          {
            key: "service.name",
            value: "restate",
            action: "upsert",
          },
          {
            key: "cluster_name",
            value: "${env:RESTATE_CLUSTER_NAME}",
            action: "insert",
          },
          {
            key: "node_name",
            from_attribute: "aws.ecs.task.arn",
            action: "insert",
          },
          {
            key: "availability_zone",
            from_attribute: "cloud.zone",
            action: "insert",
          },
          {
            pattern: "aws.*",
            action: "delete",
          },
          {
            pattern: "cloud.*",
            action: "delete",
          },
        ],
      },
    },

    exporters: otelCollectorProps.configuration.exporters,

    service: {
      pipelines: {
        ...tracesPipeline,
        ...metricsPipelines,
      },
      extensions: ["health_check", "zpages", "sigv4auth"],
    },
    extensions: {
      health_check: {},
      zpages: {},
      sigv4auth: {},
    },
  };

  return JSON.stringify(config);
}
